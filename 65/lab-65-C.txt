# Laboratorio 65-C: "RBAC en AKS" (AZURE)
 
# Este laboratorio aprenderemos a integrar RBAC de Kubernetes en AKS.

# Requisitos:
#
#   1) Una máquina virtual con Ubuntu 20.04 LTS a la que poder hacer ssh.
#
#   2) Cluster AKS. (Ver lab-00.txt)


#####################################
# Ejercicio 1. Introduccion a RBAC. #
#####################################

# Hasta el momento, hemos tenido permisos para crear, leer, actualizar y eliminar
# objetos en el cluster. Esto funciona bien en un entorno de prueba, pero no es
# recomendable para uno de producción.
#
# En los clusters de producción, la recomendación es aprovechar RBAC y conceder 
# un conjunto limitado de permisos a los usuarios. 
# 
# Será necesario configurar RBAC en Kubernetes e intregrarlo con Azure AD.
#
# RBAC tiene 3 conceptos importantes:
#
# Role:         Contiene un conjunto de permisos. Por defecto, el rol no tiene ningún
#               permiso y en consecuencia hay que especificarlos. Los permisos son del
#               tipo 'get', 'watch', 'list'... Se les llama "verbos".
#               Aquí los verbos admitidos por el API Server: 
#               https://kubernetes.io/docs/reference/access-authn-authz/authorization/#determine-the-request-verb
#
#               El rol también contiene los recursos a los que se aplican esos permisos.
#               Los recursos pueden ser todos los pods, los deployments, etc, o puede
#               ser un objeto concreto, como 'pod/mypod'.
#
# Subject:      Se refiere a la persona o a la cuenta de servicio a la que se asigna el rol.
#               En los clusteres de AKS integrados con AAD, el subject puede ser un usuario
#               o un grupo de AAD.
#
# RoleBinding:  Sirve para enlazar un subject a un rol para un contexto. Si 
#               es 'CusterRoleBinding', se refiere a la totalidad del cluster.
#
# Un concepto importante a comprender es que hay dos capas de RBAC: Los RBAC de Azure y los
# los RBAC de Kubernetes.
#
# Los RBAC de Azure tienen que ver con los roles asignados a las personas para hacer cambios 
# en Azure, como crear, modificar o borrar clusters. Los RBAC de Kubernetes tienen que ver 
# con el derecho de acceso a los recursos del cluster.
#
# Los RBACs de Kubernetes son una característica OPCIONAL. Por defecto los clusters que se
# crean tienen RBAC habilitado, sin embargo no están integrados con Azure AD. Esto significa que
# no se pueden dar permisos de Kubernetes a usuarios de AAD, y habría que integrarlo.


#############################################################
# Ejercicio 2. Habilitar la integración de Azure AD en AKS. #
#############################################################

# Una vez que el cluster ha sido integrado con Azure AD, esta funcionalidad no puede ser deshabilitada.

# Empezamos creando un grupo en Azure AD al que le asignaremos permisos en AKS:

AKS_ADMIN_GROUP_ID=$(az ad group create \
                        --display-name "aks admins" \
                        --mail-nickname aksadmins \
                        --description "Administradores de clusteres AKS" \
                        --query objectId \
                        --output tsv)


# Actualizamos la integración de Azure AD para el cluster:

az aks update \
    --resource-group myaks-rg \
    --name myaks \
    --enable-aad \
    --aad-admin-group-object-ids $AKS_ADMIN_GROUP_ID 


# Esta acción podemos verla en la GUI en:
# Home / Kubernetes Services / myaks / Cluster configuration / Kubernetes authentication and authotization


##################################################################################
# Ejercicio 3. Añadir al usuario administrador del tenant al grupo 'aks admins'. #
##################################################################################

# Al habilitar la integración con Azure AD, es necesario poner al administrador del tenant en el
# grupo de administradores del cluster, de lo contrario no podrá administrarlo por la GUI ni
# por la CLI.

# Tomamos el ID del administrador del tenant:
# (Nota: En el UPN poner el dominio verificado apropiado)

TENANT_ADMIN_USER=antsalgra_hotmail.com#EXT#@antsalgrahotmail.onmicrosoft.com 

ADMIN_USER_ID=$(az ad user show \
                    --id $TENANT_ADMIN_USER\
                    --query objectId \
                    --output tsv)

# Agregamos al admin al grupo de administradores del cluster.
az ad group member add \
    --group $AKS_ADMIN_GROUP_ID \
    --member-id $ADMIN_USER_ID


#############################################################################
# Ejercicio 4. Crear un usuario y un grupo de seguridad para asignar roles. #
#############################################################################

# Creamos un usuario del cluster:
# (Nota:) En el UPN poner el dominio verificado apropiado.

LUKE_USER_ID=$(az ad user create \
                --display-name "Luke Skywalker" \
                --password useTheForce# \
                --user-principal-name luke@antsalgrahotmail.onmicrosoft.com \
                --mail-nickname luke \
                --query objectId \
                --output tsv)


# Creamos otro grupo de seguridad, llamado 'aks users', donde pondremos a los usuarios del 
# cluster sin rol administrativo:

AKS_USER_GROUP_ID=$(az ad group create \
                        --display-name "aks users" \
                        --mail-nickname aksusers \
                        --description "usuarios de clusteres AKS" \
                        --query objectId \
                        --output tsv)


# Agregamos a Luke al grupo de usuarios del cluster:

az ad group member add \
    --group $AKS_USER_GROUP_ID \
    --member-id $LUKE_USER_ID


# Ahora necesitamos hacer que Luke sea un usuario de cluster en el RBAC de AKS.
# Esto lo habilitará para usar la Azure CLI y conseguir acceso al cluster.

# Lo primero es tomar el identificador de recurso del cluster AKS en Azure:

AKS_ID=$(az aks show \
            --resource-group myaks-rg \
            --name myaks \
            --query id \
            --output tsv)


# Es algo así: '/subscriptions/5d72e184-55f6-4093-838e-3d0f7506881a/resourcegroups/myaks-rg/providers/Microsoft.ContainerService/managedClusters/myaks'
#Lo consultamos:

echo $AKS_ID

# Creamos una asignación de rol de Azure para el grupo "aks users", del que es miembro "Luke".
# Si diera error de que el principal de seguridad no existe, esperar unos segudos porque el grupo aún no se ha creado:

sleep 60

az role assignment create \
    --assignee $AKS_USERS_GROUP_ID \
    --role "Azure Kubernetes Service Cluster User Role" \
    --scope $AKS_ID

# El resultado de esta acción se puede ver en la GUI en: Home / Kubernetes services / myaks / Access Control (IAM) / Role Assignments
# 
# El rol "Azure Kubernetes Service Cluster Role", tiene como descripción "List cluster user credential action", que 
# permite tomar las credenciales de ese usuario en el cluster y almacenarlas en .kube/config, para que posteriormente
# kubectl pueda usarlas.

# NOTA: Si se hubiera usado la CloudShell, también habría que dar permisos a AKS_USER_GROUP_ID para la cuenta de almacenamiento donde reside
#       la CloudShell. En este ejemplo no lo hacemos.



########################################
# Ejercicio 5. Configurar RBAC en AKS. #
########################################

# Para hacer la demo, crearemos dos 'namespaces' y desplegaremos la aplicación de voto de 
# Azure en cada espacio de nombres. Asignaremos al grupo que creamos acceso de solo lectura
# de ámbito de cluster a los pods. Al usuario de asignaremos la capacidad de eliminar pods 
# solo en uno de los espacios de nombres.
#
# Crearemos los siguientes objetos en k8s.
#
# Un 'ClusterRole' para dar el acceso de solo lectura a todos los pods del cluster 
# Un 'ClusterRoleBinding' para asignar al grupo 'aks users' el rol anterior de solo lectura.
# Otro 'ClusterRole' para dar permisos de eliminación en el espacio de nombres 'delete-access'
# Otro 'ClusterRoleBinding' para asignar al usuario 'Luke' el rol de eliminación anterior.


# Creamos los dos espacios de nombres. "no-access" y "delete-access". La idea es que el usuario que
# vamos a crear pueda borrar pods en "delete-access" y no pueda hacerlo en "no-access":

kubectl create ns no-access

kubectl create ns delete-access


# Cambiamos al directorio de trabajo:

cd ~/k8s_desarrolladores/65


# Desplegamos la aplicación de voto en los espacios de nombres:

kubectl create -f lab-65-C-azure-vote.yaml --namespace no-access

kubectl create -f lab-65-C-azure-vote.yaml --namespace delete-access


# Comprobamos:

kubectl get all --namespace no-access 

kubectl get all --namespace delete-access 


# Ahora vamos a crear el objeto 'ClusterRole', que asignará permisos de solo lectura en todo el cluster.
# Editamos el archivo 'lab-65-C-clusterRole.yaml':

code lab-65-C-clusterRole.yaml


# Línea 2:  Define la creación de una instancia 'ClusterRole'
#
# Línea 4:  A la que le asigna el nombre 'readOnly'
#
# Línea 6:  Concede acceso a todos los grupos de la API.
#           https://kubernetes.io/docs/reference/using-api/#api-groups
#
# Línea 7:  Concede acceso a todos los pods.
#
# Línea 8:  Concede acceso a las acciontes 'get', 'watch' y 'list'.
#           https://kubernetes.io/docs/reference/access-authn-authz/authorization/#determine-the-request-verb


# Creamos el objeto 'ClusterRole':

kubectl create -f lab-65-C-clusterRole.yaml


# Comprobamos:

kubectl get clusterRole


# Podemos inspeccionalo:

kubectl describe clusterRole readOnly


# Copiamos en el portapapeles $AKS_USER_GROUP_ID. Lo necesitaremos en un momento:

echo $AKS_USER_GROUP_ID


# Ahora vamos a crear un objeto 'ClusterRoleBinding' que enlaza el rol a un usuario o grupo.
# Editamos el archivo 'lab-65-C-clusterRoleBinding.yaml':

code lab-65-C-clusterRoleBinding.yaml


# Línea 2:      Define que estamos creando una instancia 'ClusterRoleBinding'.
#
# Línea 4:      Le asigna el nombre 'readOnlyBinding'.
#
# Líneas 5-8:   Hace referencia al objeto 'ClusterRole' que creamos anteriormente.
#
# Líneas 9-12:  Se refiere al grupo de AAD que creamos antes (aks users).
#               IMPORTANTE!!!! Sustituir en la línea 12 el id que tenemos copiado en el portapapeles.

# Guardar los cambios y salir.

# Creamos el objeto 'ClusterRoleBinding':

kubectl create -f lab-65-C-clusterRoleBinding.yaml


# Comprobamos:

kubectl get clusterRoleBinding


# Lo inspeccionamos:

kubectl describe clusterRoleBinding readOnlyBinding


# A continuación crearemos un rol que permite la eliminación en el espacio de nombres 'delete-access'.
# Editamos el archivo 'lab-65-C-role.yaml'

code lab-65-C-role.yaml

# Línea 2:      Se indica que se está creando una instancia de 'Role' y no de 'ClusterRole'. La instancia de 'Role'
#               no se aplica a todo el cluster.
#
# Línea 5:      Aquí ponemos el espacio de nombres al que se aplica.
#
# Líneas 7-9:   Los tipos de recursos afectados y los verbos permitidos.

# Creamos el rol:

kubectl create -f lab-65-C-role.yaml


# Comprobamos (ojo con el espacio de nombres):

kubectl get role --namespace delete-access


# Inspeccionamos:

kubectl describe role deleteRole  --namespace delete-access

# Por último creamos una instancia de 'RoleBinding' para asignar el role al usuario 'Luke'.
# Editamos el archivo 'lab-65-C-roleBinding.yaml':

code lab-65-C-roleBinding.yaml


# Línea 2:      Crea una instancia de un 'RoleBinding' y no de un 'ClusterRoleBinding' porque lo que se 
#               está asociando es un 'Role' y no un 'ClusterRole'.
#
# Línea 5:      Indica el espacio de nombres en el que se crea este rol.
#
# Línea 7:      Hacer referencia a una instancia 'Role' y no a una 'ClusterRole'
#
# Líneas 11-13: Define un usuario en lugar de un grupo. 
#               IMPORTANTE. Poner el usuario que hemos creado en la línea 13.

# Creamos la instancia.
kubectl create -f roleBinding.yaml

# Comprobamos.
kubectl get roleBinding --namespace delete-access

# Inspeccionamos.
kubectl describe roleBinding deleteBinding --namespace delete-access


#######################################
# Verificar RBAC para el usuario Luke #
#######################################

# Cerramos la sesión de Azure del usuario actual.
az logout

# Borramos la caché de cuentas de Azure.
az account clear

# Iniciamos sesión con el usuario 'Luke@antsalgrahotmail.onmicrosoft.com' y password 'useTheForce#'.
az login

# ¡¡¡¡MUY IMPORTANTE!!!!
#
# az aks get-credentials toma las credenciales de un cluster administrado de AKS y las almacena
# en el archivo "~/.kube/config" de forma que "kubectl" pueda usarlas.
#
# Hasta el momento, hemos usado la CLI como "administrador", usando el parámetro "--admin" 
# del comando anterior. Este parámetro se utiliza para:
#
#   --admin -a    : Get cluster administrator credentials.  Default: cluster user credentials.
#                   On clusters with Azure Active Directory integration, this bypasses normal Azure AD
#                   authentication and can be used if you're permanently blocked by not having access to a valid
#                   Azure AD group with access to your cluster. Requires 'Azure Kubernetes Service Cluster
#                   Admin' role.
#
# Es decir, que en lugar de poner a un usuario en un grupo asignado al rol "Azure Kubernetes Service Cluster Admin"
# hemos utilizado "--admin" para saltarnos el RBAC de Azure.
#
# Como ahora mismo es esto lo que probamos, descargamos las credenciales para el usuario "Luke" SIN USAR "--admin".

# Otro parámetro interesante es "--overwrite-existing" cuya finalidad es:
#
#   --overwrite-existing   : Overwrite any existing cluster entry with the same name.
#
# Que debemos utilizarlo si le cambiamos los permisos al usuario en Azure. 
#
# En definitiva, para descargar las credenciales de "Luke" debemos poner.
az aks get-credentials \
    --resource-group myaks-rg \
    --name myaks \
    --overwrite-existing

# Podemos ver que estamos logados a la subscripción de Azure con el usuario "Luke" con el comando:
az account show

# Vamos a verificar si el usuario tiene permiso para ver los pods en todos los espacios de nombres.
# Debe ver los pods en los dos espacios.
kubectl get pods --namespace no-access
kubectl get pods --namespace delete-access

# Esto es debido al objeto 'ClusterRole' asignado al grupo (aks users). De hecho, al aplicarse al cluster
# tendría acceso a todos los espacios de nombres, como puede comprobarse con el siguiente comando.
kubectl get pods --all-namespaces

# Ahora comprobamos los permisos de eliminación. Solo debe poder eliminar del espacio de nombres 'delete-access'
kubectl delete pod --all --namespace delete-access
kubectl delete pod --all --namespace no-access

# Para limpiar, INICIAMOS SESIÓN CON EL USUARIO ADMINISTRADOR.
az logout

# Borramos la caché de cuentas de Azure.
az account clear

# Iniciamos sesión con el usuario 'Luke@antsalgrahotmail.onmicrosoft.com' y password 'useTheForce#'.
az login

# Actualmente el cluster tiene configurado RBAC y la autenticación de AAD. Actualizamos credenciales.
az aks get-credentials \
    --resource-group myaks-rg \
    --name myaks \
    --overwrite-existing

# Alternativamente podemos saltarnos la autenticación de AAD y tener credenciales de aministrador en el cluster así:
az aks get-credentials \
    --resource-group myaks-rg \
    --name myaks \
    --overwrite-existing \
    --admin


kubectl delete -f azure-vote.yaml -n no-access
kubectl delete -f azure-vote.yaml -n delete-access
kubectl delete -f .
kubectl delete ns no-access
kubectl delete ns delete-access


#####################################################
# Capítulo 9. Asignar identidades de AAD a los pods #
#####################################################

# IMPORTANTE: REQUIERE HABER INTEGRADO AAD EN AKS. SE HIZO EN EL CAPÍTULO ANTERIOR.

# En este capítulo veremos como se puede integrar una aplicación que corre en AKS con Azure AD.
# Aprenderemos a asignar a los pods una identidad en Azure, de forma que puedan interactuar con
# otros recursos de Azure.
#
# En Azure, las identidades de aplicación usan una funcionalidad llamada "Service Principal".
# Un Service Principal es el equivalente a una cuenta de servicio tradicional. La aplicación
# puede usar el "Service Principal"  para autenticarse con Azure AD y obtener acceso a los recursos,
# que pueden ser un Azure Blob Storage o un Key Vault, entre otros. También podrían ser aplicaciones
# que has desarrollado y que estan integradas con AAD.

# Hay dos formas para autenticar un service principal: Usar un password o una combinación de 
# certificado y clave privada. Aunque ambas son formas seguras de autenticar a la aplicaciones, la
# administración de los passwords o los certificados y la rotación de las claves pueden ser
# laboriosas.
#
# Las "Managed Identities" de Azure hacen que la autenticación de un service principal sea más 
# sencilla. Funcionan asignando una identidad a un recurso de computación en Azure, como podrían
# ser una máquina virtual o una Azure Function.
#
# Estos recursos pueden autenticarse usando esa identidad administrada mediante la llamada a un
# endpoint que solo es accesible a esa máquina o function. Es un tipo de autenticación segura que 
# requiere que administremos ni passwords ni certificados.

# Las identidades de pods administradas en Azure AD nos permiten asignar identidades administradas
# a los pods en AKS. Debido a que los pods en Kubernetes corren sobre máquinas virtuales, por 
# defecto, cada pod debería ser capaz de acceder al endpoint de la identidad administrada y 
# autenticarse usando dicha identidad.

# En este capítulo configuraremos la identidad de pods administrada en el cluster AKS y la Usaremos
# para acceder a un Blob Storage. En el capítulo posteriore se utilizará la identidad de pod 
# administrada para acceder a un Key Vault y administrar secretos de Kubernetes.

#######################################################
# Introducción a las identidades de pod administradas #
#######################################################

# Como se explicó, las identidades administradas en Azure son una forma de autenticar
# de forma segura a las aplicaciones que corren dentro de Azure. Exiten dos typos de
# identidades administradas, que se diferencian en la forma en la que se relacionan con
# los recursos:
#
# System Asigned:   Tiene una relación 1:1 con el recurso (por ejemplo una máquina virtual).
#                   Este tipo de identidad administrada comparte el ciclo de vida con el
#                   recurso, lo que significa que si el recurso se elimina, la identidad
#                   administrada también se borra.
#
# User Assigned:    Las identidades administradas asignadas por el usuario son recursos 
#                   idenpendientes. Pueden estar relacionadas con diferentes recursos. Cuando
#                   se elimina el recurso, la identidad administrada NO se borra.
#
# Ambos tipos de identidades administradas funcionan de la misma forma una vez que han sido
# creadas y asociadas con un recurso. Así es como las identidades administradas funcionan 
# desde la perspectiva de una aplicación:
#
# 1.    Tu aplicación que se ejecuta en Azure solicita un token al servicio IMDS (Instance
#       Metadata Service) [1]. IMDS está solo disponible para el propio recurso, en una IP no
#       enrutable (169.254.169.254)
#
# 2.    IMDS solicitará un token a Azure AD [2]. Usa un certificado que está configurado para tu
#       identidad administrada y es solo conocido por IMDS.
#
# 3.    Azure AD devolverá un token a IMDS [3], que a su vez, lo devolverá a la aplicación [4].
#
# 4.    La aplicación puede usar ese token para autenticarse con otros recursos [5], por ejemplo,
#       un Blob Storage.
#
#
#     VIRTUAL MACHINE                                                   AZURE
#  ----------------------                -------------------------------------------------------------------------
#
#             (Solicita token) [1] --->                                       (Se autentica) [2]--->
#     /APP/                              /INSTANCE METADADA SERVICE (IMDS)/                             /Azure AD/
#       |     <--- (recibe token) [4]                                         <--- (recibe token) [3]
#       |
#       |  (Accede usando token) [5]
#       |
#  /Azure Resource/
#
# Cuando se ejecutan varios pods en la misma máquina vitual en un cluster de Kubernetes, por
# defecto cada pod puede alcanzar el endpoint IDMS. Esto significa que cada pod podría tener
# acceso a las identidades configuradas para esa máquina virtual.
#
# El complemento de identidades de pod administradas de AAD configura el cluster de forma que
# los pods ya no pieden tener acceso directo al endpoint IDMS para solicitan un token de acceso.
# Configura el cluster de forma que los pods que estén intentando acceder al endpoint IDMS [1]
# conectarán con un DaemonSet que corre en el cluster, y que recibe el nombre de Node Managed 
# identity (NMI). 
#
# NMI verificará a qué identidades debería tener acceso el pod. Si el pod está configurado para
# tener acceso a la identidad solicitada, entonces el DaemonSet NMI conectará con el IMDS (pasos
# [2] a [5]) para obtener el token y lo entregará al pod [6]. 
#
# El pod(s) usará ese token para acceder a los recursos de Azure [7]


#     VIRTUAL MACHINE                                                                      AZURE
#  --------------------------------------------      -------------------------------------------------------------------------
#
#            (Solicita token) [1] -->               (Solicita token) [2] -->          (Se autentica) [3]-->
#     /POD/                              /NMI/                                /IMDS/                          /AAD/
#       |    <-- (recibe token) [6]                 <-- (recibe token) [5]           <-- (recibe token) [4]
#       |
#       |
#       |  (Accede usando token) [7]
#       |
#  /Azure Resource/

# De esta forma, podemos controlar los pods del cluster que tendrán acceso a ciertas identidades y, 
# en consecuencia, a cierto recursos de Azure.

#########################################################################
# Configurar un cluster con identidades de pod aministradas de Azure AD #
#########################################################################

# El complemento de identidades de pod administradas en un cluster en ejecución,
# se realiza por medio de la preview de aks. En la fecha de este escrito, 
# Enero 2022, aún está en beta y no forma parte de la CLI oficial.

# Para poder instalar este complemento, debemos agregar dicha extensión a la CLI
az extension add --name aks-preview

# Actualiamos por si Microsoft hubiera publicado una nueva versión. 
az extension update --name aks-preview

# Registramos las identidades de pod administradas de Azure AD.
az feature register \
    --name EnablePodIdentityPreview \
    --namespace Microsoft.ContainerService

# Tal y como sugiere el warning, se requiere este comando para que se propague el cambio.
az provider register --name Microsoft.ContainerService

# Comprobar que la característica de identidad de pods se ha registrado en la subscripción.
# ¡¡¡¡IMPORTANTE!!!!!
# Esperar hasta que aparezca 'Registered' en 'RegistrationState'. Lleva bastante tiempo. 10-15 minutos.
az feature show \
    --name EnablePodIdentityPreview \
    --namespace Microsoft.ContainerService \
    -o table

# Actualizamos el cluster para que use la identidades de pod administradas.
az aks update \
    --resource-group myaks-rg  \
    --name myaks \
    --enable-managed-identity \
    --enable-pod-identity \
    --enable-pod-identity-with-kubenet

# Volvemos a refrescar as credenciales para kubectl.
az aks get-credentials \
    --resource-group myaks-rg \
    --name myaks \
    --overwrite-existing

# Listamos nodos para comprobar
kubectl get nodes

####################################
# Asociar una identidad al cluster #
####################################

# Para empezar, vamos a crear una nueva identidad administrada asignada por el usuario en Azure.
az identity create \
    --resource-group myaks-rg \
    --name access-blob-id \
    --location westeurope 

# En la GUI se puede ver la identidad administrada en Home / Managed Identities / access-blob-id

# Una vez creada, necesitamos copiar el 'clientId' (identificador único de la nueva identidad)
# y el 'id' (identificador del recurso), que serán usados en breve.
CLIENT_ID=$(az identity show \
                --resource-group myaks-rg \
                --name access-blob-id \
                --query clientId \
                -o tsv)
RESOURCE_ID=$(az identity show \
                --resource-group myaks-rg \
                --name access-blob-id \
                --query id \
                -o tsv)

# Comprobamos
echo $CLIENT_ID
echo $RESOURCE_ID

# Ahora estamos preparados para asociar la identidad administrada al cluster AKS.
az aks pod-identity add \
    --resource-group myaks-rg \
    --cluster-name myaks \
    --namespace default \
    --name access-blob-id \
    --identity-resource-id $RESOURCE_ID

# Podemos comprobar que la identidad ha sido asignada al cluster y está disponible para su uso, con este comando.
kubectl get azureidentity

##############################################
# Usar un pod con una identidad administrada #
##############################################

# Vamos a crear una cuenta de almacenamiento y usaremos la identidad administrada para acceder a ella.
STORAGE_ACCOUNT_NAME=myaks20220114sto
az storage account create \
    --name $STORAGE_ACCOUNT_NAME \
    --resource-group myaks-rg \
    --location westeurope \
    --sku Standard_LRS \
    --kind StorageV2

# Tomamos el contexto de la cuenta de almacenamiento, que es algo como esto:
# '/subscriptions/5d72e184-55f6-4093-838e-3d0f7506881a/resourceGroups/myaks-rg/providers/Microsoft.Storage/storageAccounts/myaks20220114sto'
STORAGE_ACCOUNT_SCOPE=$(az storage account show \
                            --resource-group myaks-rg \
                            --name $STORAGE_ACCOUNT_NAME \
                            --query id \
                            -o tsv)

# Comprobamos
echo $STORAGE_ACCOUNT_SCOPE

# Ahora asignaremos la identidad administrada acceso a la cuenta de almacenamiento.
# En la interfaz gráfica se hace en: Home / Storage Accounts / <cuenta almacenamiento> / Access Control (IAM) / Role Assignments / add
# y elegir el rol "Storage Blob Data Contributor" y asignarlo a la idendidad administrada asignada por el usuario 'access-blob-id'
# para el contexto de la cuenta de almacenamiento. # Con la CLI sería.
az role assignment create --assignee $CLIENT_ID --role "Storage Blob Data Contributor" --scope $STORAGE_ACCOUNT_SCOPE 

# Vamos a crear un archivo y lo subiremos al conetenedor (DE BLOB) que vamos a crear. Posteriormente, comprobaremos
# que podemos acceder al archivo desde un pod de AKS.

# Vamos a tomar credenciales para poder interactuar con la cuenta de almacenamiento.
# Los permisos son  (a)dd (c)reate (d)elete (l)ist (p)rocess (r)ead (u)pdate (w)rite (a)dd (c)reate (d)elete (l)ist (p)rocess (r)ead (u)pdate (w)rite.
PERMISSIONS=cdlruwap

# Los servicios para los que se concenden el acceso podrían ser: (b)lob (f)ile (q)ueue (t)able.
SERVICES=b

# Los tipos de recursos para los que solicitamos acceso podrían ser: (s)ervice (c)ontainer (o)bject.
RESOURCE_TYPES=sco

# Solicitamos de la clave SAS expire en 30 minutos (es el tiempo que tenemos para crear el contenedor y subir el archivo.)
END=`date -u -d "30 minutes" '+%Y-%m-%dT%H:%MZ'`

# Ejecutar el comando para obtener la SAS. Como es la primera vez, aparece una advertencia. A partir de ahora usaremos
# el token SAS generado para autenticarnos desde la CLI
STORAGE_ACCOUNT_SAS_TOKEN=$(az storage account generate-sas \
                                --permissions $PERMISSIONS \
                                --account-name $STORAGE_ACCOUNT_NAME \
                                --services $SERVICES \
                                --resource-types $RESOURCE_TYPES \
                                --expiry $END \
                                -o tsv)

# Probamos
echo $STORAGE_ACCOUNT_SAS_TOKEN

# Creamos el contenedor de BLOB que será de tipo privado.
BLOB_CONTAINER_NAME=uploadedfiles
az storage container create \
    --name $BLOB_CONTAINER_NAME \
    --account-name $STORAGE_ACCOUNT_NAME \
    --sas-token $STORAGE_ACCOUNT_SAS_TOKEN

# El contenedor de BLOB creado se puede ver en la GUI en: 'Home / Resource groups / myaks-rg / <cuenta de almacenamiento> / $BLOB_CONTAINER_NAME'

# Cambiamos al directorio de trabajo.
cd ~/k8sAzure/Identidad_administrada

# Creamos un archivo de prueba par demostrar todo esto.
echo "Este es un archivo de texto almacenado en un BLOB en un contenedor de BLOBs de una cuenta de almacenamiento en Azure" > file.txt

# Procedemos a subir el archivo a la cuenta de almacenamiento.
FILENAME_IN_AZURE=file_in_Azure.txt
az storage blob upload --file ./file.txt --container-name $BLOB_CONTAINER_NAME --name $FILENAME_IN_AZURE.txt  --account-name $STORAGE_ACCOUNT_NAME --sas-token $STORAGE_ACCOUNT_SAS_TOKEN

# Vamos a intentar acceder al archivo desde un pod. Para ello crearemos un nuevo desployment que contendrá un vínculo con
# la identidad administrada que creamos anteriormente. Editamos el archivo 'deployment-with-identity.yaml'
code deployment-with-identity.yaml

# Línea 13:     Se asocia el pod (creado por el deployment) con la identidad administrada. Cualquier pod con esa
#               etiqueta (label) podrá acceder a la identidad administrada.
#
# Líneas 16-18: Se usará la imagen 'azure-cli' que proporcionará los comandos 'az' dentro del pod.

# Creamos el deployment
kubectl create -f deployment-with-identity.yaml

# Comprobamos.
kubectl get pods

# Mostrar el valor de las variables. Necesitaremos copiarlas al pod.
echo $CLIENT_ID
echo $STORAGE_ACCOUNT_NAME
echo $BLOB_CONTAINER_NAME
echo $FILENAME_IN_AZURE


# Cuando el pod esté iniciado abrimos una shell en él.
kubectl exec -it <access-blob pod name> -- sh

# IMPORTANTE!!!! DENTRO DEL POD.
# Nos autenticamos con la API de Azure usando la identidad creada (El deployment permite usarla en los pods)
az login \
    --identity \
    --username <CLIENT ID COPIADO ANTES> \
    --allow-no-subscription \
    -o table

# Intentamos acceder con esa identidad al BLOB. Copiar y pegar las variables.
FILENAME=file.txt
az storage blob download \
    --account-name <STORAGE_ACCOUNT_NAME> \
    --container-name <BLOB_CONTAINER_NAME> \
    --auth-mode login \
    --name <FILENAME_IN_AZURE> \
    --file $FILENAME \
    -o table

# Comprobamos que lo ha descargado sin problemas.
ls -l file.txt
cat file.txt

# Salimos del pod
exit 

# Ahora volvemos a hacerlo mismo, pero con la diferencia que el deployment no incorpora la identidad administrada, por lo que
# el pod NO PODRÁ acceder al BLOB.

# Editamos el archivo 'deployment-without-identity'
code deployment-without-identity.yaml

# Comprobar que ya no existe la etiqueta 'aadpodidbinding: access-blob-id¡

# Desplegamos
kubectl create -f deployment-without-identity.yaml

# Comprobamos
kubectl get pods

# Ejecutamos una shell en el contenedor.
kubectl exec -it <no-access-blob pod name> -- sh

# Intentamos autenticarnos en la API de Azure usando el mismo CLIENT-ID.
# Fallará porque el deployment no ha asignado al pod dicha identidad administrada.
az login \
    --identity \
    --username <CLIENT ID COPIADO ANTES> \
    --allow-no-subscription \
    -o table

# Salimos del contenedor
exit 

# Borramos, pero no todo, porque necesitaremos el cluster configurado para poder
# usar identidades administradas de Azure AD para acceder al 'Key Vault'

# Eliminamos la identidad administrada que creamos.
az aks pod-identity delete \
    --resource-group myaks-rg \
    --cluster-name myaks \
    --namespace default \
    --name access-blob-id

# Eliminamos deployments.
kubectl delete -f deployment-with-identity.yaml
kubectl delete -f deployment-without-identity.yaml

# Comprobamos.
kubectl get all

# Borramos la cuenta de almacenamiento.
az storage account delete \
    --name $STORAGE_ACCOUNT_NAME \
    --resource-group myaks-rg \
    --yes
