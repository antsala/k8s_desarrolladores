# Laboratorio 35: "Ingress"
 
# Este laboratorio aprenderemos a usar los objetos Ingress

# Requisitos:
#
#   1) Una máquina virtual con Ubuntu 20.04 LTS a la que poder hacer ssh.
#
#   2)  Tener instalado el runtime de podman. (ver lab-06-A.txt, Ejercicio 1 y 2)


################################################
# Ejercicio 1:  Despliegue de las aplicaciones #
################################################

# Entramos en el directorio del laboratorio

cd ~/k8s_desarrolladores/35

# Procedemos a redesplegar las aplicaciones 'hellocontainer' y 'mongodb' de los ejercicios anteriores,
# pero con un cambio notable: Puesto que vamos a usar un controlador Ingress para reenviar el tráfico
# a los servicios del Frontend de las aplicaciones, éstos servicios deben convertirse a servicios INTERNOS.

# Para el Frontend de 'helloContainer' no hay cambios. Editamos el archivo para recordar qué contiene.

code lab-35-helloContainer-deployment.yaml

# La línea 21, expresa que los contenedores estarán dando servicio en el puerto 8080.

# Cerramos el archivo sin modificarlo.

# 'helloContainer' definía un servicio EXTERNO para exponer los pods. Ahora ese servicio debe ser reconvertido
# a INTERNO.

# Editamos el archivo 'lab-35-helloContainer-service.yaml'

code lab-35-helloContainer-service.yaml

# El cambio más notable es que NO APARECE el parámetro 'type: LoadBalancer' en la especificación del servicio.
# Esto lo convierte en un SERVICIO INTERNO.

# Además, en la línea 4, se cambia el nombre del servicio a 'hello-container-internal-service'.

# Por otro lado, el servicio escucha en el puerto 4000 (Línea 10) y reenvía el tráfico al puerto '8080' de los
# pods (Línea 11)

# Guardamos sin salir.

# Aplicamos ambos archivos.

kubectl apply -f lab-35-helloContainer-deployment.yaml

kubectl apply -f lab-35-helloContainer-service.yaml


# Comprobamos que se hayan creado los objetos:

kubectl get all

# Miramos cómo ha quedado el servicio interno.

kubectl get service hello-container-internal-service


# La salida del comando anterior será similar a esta:
#
# NAME                               TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)    AGE
# hello-container-internal-service   ClusterIP   10.101.242.181   <none>        4000/TCP   8m15s

# El tipo 'ClusterIP' y la ausencia de 'EXTERNAL-IP' identifican al servicio como INTERNO.


# Procedemos ahora al despliegue de la segunda aplicación.

# Esta contiene un Frontend, un Backend, un secreto y un configmap.

# El objeto 'secret' y el 'configmap' no tienen cambios. Aplicamos directamente sus archivos YAML.

kubectl apply -f lab-35-mongodb-secret.yaml

kubectl apply -f lab-35-mongodb-configmap.yaml


# Comprobamos que se ha creado el secreto.

kubectl get secret mongodb-secret

# La salida debe ser parecida a esta:
# 
# NAME             TYPE     DATA   AGE
# mongodb-secret   Opaque   2      40s


# Hacemos lo propio para el configmap.

kubectl get configmap mongodb-configmap


# Y la salida es:
#
# NAME                DATA   AGE
# mongodb-configmap   1      12h


# Procedemos a desplegar el Frontend y el Backend.


# El Backend no sufre cambios, editamos el archivo para recordarlo:

code lab-35-mongodb.yaml

# Las líneas 42 y 43 define el puerto en el que escuchará sel servicio de backend ('27017') y 
# el tráfico será reenviado al puerto '27017' del pod de mongodb server.

# Salimos sin modificar nada.


# Por último, para el Frontend si hay cambios. 
# Editamos el archivo 'lab-35-mongo-express.yaml'

code lab-35-mongo-express.yaml


# El cambio más notable es que NO APARECE el parámetro 'type: LoadBalancer' en la especificación del servicio.
# Esto lo convierte en un SERVICIO INTERNO.

# Además, en la línea 42, se cambia el nombre del servicio a 'mongo-express-internal-service'.

# Por otro lado, el servicio escucha en el puerto 5000 (Línea 48) y reenvía el tráfico al puerto '8081' del
# pod 'mongo-express' (Línea 49)

# Guardamos sin salir.


# Aplicamos los archivos YAML.

kubectl apply -f lab-35-mongodb.yaml

kubectl apply -f lab-35-mongo-express.yaml


# Verificamos los servicios asociados a la aplicación

kubectl get services mongodb-service mongo-express-internal-service


# La salida es:
#
# NAME                             TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)     AGE
# mongodb-service                  ClusterIP   10.107.141.33   <none>        27017/TCP   4m25s
# mongo-express-internal-service   ClusterIP   10.104.152.51   <none>        5000/TCP    3m44s

# Ambos servicios son internos ('ClusterIP')

# A falta de crear el objeto 'Ingress', el cluster debe contener lo siguiente:

kubectl get all


# La salida indica que hay 5 pods, 4 servicios, 3 deployments sus respectivos (3) replicasets.

# NAME                                             READY   STATUS    RESTARTS   AGE
# pod/hello-container-deployment-566d999d9-4wpdw   1/1     Running   0          30m
# pod/hello-container-deployment-566d999d9-9nf5z   1/1     Running   0          30m
# pod/hello-container-deployment-566d999d9-xh5cz   1/1     Running   0          30m
# pod/mongo-express-deployment-68c4748bd6-jwcrx    1/1     Running   0          5m13s
# pod/mongodb-deployment-7bb6c6c4c7-mp8jq          1/1     Running   0          5m54s
# 
# NAME                                       TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)     AGE
# service/hello-container-internal-service   ClusterIP   10.101.242.181   <none>        4000/TCP    30m
# service/kubernetes                         ClusterIP   10.96.0.1        <none>        443/TCP     22h
# service/mongo-express-internal-service     ClusterIP   10.104.152.51    <none>        5000/TCP    5m13s
# service/mongodb-service                    ClusterIP   10.107.141.33    <none>        27017/TCP   5m54s
# 
# NAME                                         READY   UP-TO-DATE   AVAILABLE   AGE
# deployment.apps/hello-container-deployment   3/3     3            3           30m
# deployment.apps/mongo-express-deployment     1/1     1            1           5m13s
# deployment.apps/mongodb-deployment           1/1     1            1           5m54s
#
# NAME                                                   DESIRED   CURRENT   READY   AGE
# replicaset.apps/hello-container-deployment-566d999d9   3         3         3       30m
# replicaset.apps/mongo-express-deployment-68c4748bd6    1         1         1       5m13s
# replicaset.apps/mongodb-deployment-7bb6c6c4c7          1         1         1       5m54s



#############################################
# Ejercicio 2:  Creación del objeto Ingress #
#############################################

# En este momento tenemos las aplicaciones funcionando, pero no son accesibles a ser todos los servicios INTERNOS.

# Vamos a agregar un objeto 'Ingress' que definirá las reglas que aplicará el 'Controlador Ingress' (aun por crear)
# para enviar el tráfico externo a cada servicio de Frontend.

# Editamos el archivo 'lab-35-ingress.yaml'

code lab-35-ingress.yaml


# Este YAML hace lo siguiente:

# Línea 1:          Versión de la API.
# 
# Línea 2:          Declara el tipo de objeto como 'Ingress'.
#
# Línea 4:          Este objeto se llamará 'my-ingress'.
#
# Línea 6:          Nombre de la clase: Ver https://kubernetes.io/docs/concepts/services-networking/ingress/#the-ingress-resource
#
# Línea 7:          Empieza la definición de las reglas que se van a aplicar al tráfico.
#
# Línea 8:          Se aplicarán si la URL contiene el dominio dns 'midominio.com'
#
# Línea 9:          Comienza la definición para las reglas 'http'.
#
# Líneas 11-17:     Regla para reenviar tráfico a la aplicación 'helloContainer'.
#
# Línea 11 y 12:    Si la URI comienza por '/hellocontainer'
#
# Línea 15 y 17:    Se reenvia el tráfico al servicio 'hello-container-internal-service' puerto '4000'.
#
# Líneas 18-24:     Regla para reenviar tráfico a la aplicación 'mongo-express'.
#
# Línea 18 y 19:    Si la URI comienza por  '/mongoexpress'
#
# Línea 22 y 24:    Se reenvia el tráfico al servicio 'mongo-express-internal-service' puerto '5000'.


# En resumen, el flujo de redirecciones será:

# Si usuario conecta a 'http://midominio.com/hellocontainer' --> hello-container-internal-service:4000 --> pod:8080

# Si usuario conecta a 'http://midominio.com/mongoexpress' --> mongo-express-internal-service:5000 --> pods:8081


# Salimos sin modificar nada.

# Creamos el objeto 'Ingress'

kubectl apply -f lab-35-ingress.yaml


# Comprobamos que se ha creado.

kubectl get ingress my-ingress

# La salida es:
#
# NAME         CLASS    HOSTS           ADDRESS   PORTS   AGE
# my-ingress   my-class   midominio.com             80      7m51s


# Vemos más información:

kubectl describe ingress my-ingress

# La salida mostrará algo como esto:
# (Nota: observar los 'path' y los 'backends')
#
#
# Name:             my-ingress
# Labels:           <none>
# Namespace:        default
# Address:          
# Default backend:  default-http-backend:80 (<error: endpoints "default-http-backend" not found>)
# Rules:
#   Host           Path  Backends
#   ----           ----  --------
#   midominio.com  
#                   /hellocontainer   hello-container-internal-service:4000 (172.17.0.3:8080,172.17.0.4:8080,172.17.0.5:8080)
#                   /mongoexpress     mongo-express-internal-service:5000 (172.17.0.7:8081)
# Annotations:     <none>
# Events:          <none>


#################################################
# Ejercicio 3:  Instalar el Controlador Ingress #
#################################################

# Minikube ya viene con un controlador ingress instalado, de forma que solo debemos habilitarlo:

minikube addons enable ingress

# La salida mostrará lo siguiente:
#
#     ▪ Using image k8s.gcr.io/ingress-nginx/kube-webhook-certgen:v1.1.1
#     ▪ Using image k8s.gcr.io/ingress-nginx/controller:v1.1.0
#     ▪ Using image k8s.gcr.io/ingress-nginx/kube-webhook-certgen:v1.1.1
#     Verifying ingress addon...
#     The 'ingress' addon is enabled



##########################################################
# Ejercicio 4:  Configurar el Registro de Recurso de DNS #
##########################################################


# En el arhchivo YAML del objeto ingress hemos puesto indicado que que host (entrypoint) del
# cluster es 'midominio.com'. Debemos crear un registro de tipo A en el registrador de forma que
# se pueda resolver a una IP.

# Tomamos las IP del nodo de minikube

minikube_ip=$(minikube ip)

echo $minikube_ip


# Copiar la IP en el portapapeles.

# A falta de usar un servidor DNS para crear el registro 'A' para 'midominio.com', editamos el archivo 'hosts'

sudo nano /etc/hosts


# En la sección IPv4, creamos una línea nueva en la que debe aparecer la IP copiada anteriormente y el nombre 'midominio.com'
#
# Debería ser algo parecido a esto:
#
# 127.0.0.1       localhost
# 127.0.1.1       ubu
# 192.168.49.2    midominio.com       # <---- Esta es la línea que hemos añadido.

# Salimos y guardamos.

# Comprobamos la resolución DNS:

host midominio.com 


# La salida será como esta, donde aparece la IP de Minikube.
#
# midominio.com has address 192.168.49.2



















# Comprobamos los objetos presentes en el cluster.

kubectl get all 


# Solo debe quedar el servicio de Kubernetes.
# NAME                 TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE
# service/kubernetes   ClusterIP   10.96.0.1    <none>        443/TCP   53m



#######################
# FIN DEL LABORATORIO #
#######################

