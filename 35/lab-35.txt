# Laboratorio 35: "Ingress"
 
# Este laboratorio aprenderemos a usar los objetos Ingress

# Requisitos:
#
#   1) Una máquina virtual con Ubuntu 20.04 LTS a la que poder hacer ssh.
#
#   2)  Tener instalado el runtime de podman. (ver lab-06-A.txt, Ejercicio 1 y 2)


################################################
# Ejercicio 1:  Despliegue de las aplicaciones #
################################################

# Entramos en el directorio del laboratorio

cd ~/k8s_desarrolladores/35

# Procedemos a redesplegar las aplicaciones 'hellocontainer' y 'mongodb' de los ejercicios anteriores,
# pero con un cambio notable: Puesto que vamos a usar un controlador Ingress para reenviar el tráfico
# a los servicios del Frontend de las aplicaciones, éstos servicios deben convertirse a servicios INTERNOS.

# Para el Frontend de 'helloContainer' no hay cambios. Editamos el archivo para recordar qué contiene.

code lab-35-helloContainer-deployment.yaml

# La línea 21, expresa que los contenedores estarán dando servicio en el puerto 8080.

# Cerramos el archivo sin modificarlo.

# 'helloContainer' definía un servicio EXTERNO para exponer los pods. Ahora ese servicio debe ser reconvertido
# a INTERNO.

# Editamos el archivo 'lab-35-helloContainer-service.yaml'

code lab-35-helloContainer-service.yaml

# El cambio más notable es que NO APARECE el parámetro 'type: LoadBalancer' en la especificación del servicio.
# Esto lo convierte en un SERVICIO INTERNO.

# Además, en la línea 4, se cambia el nombre del servicio a 'hello-container-internal-service'.

# Por otro lado, el servicio escucha en el puerto 4000 (Línea 10) y reenvía el tráfico al puerto '8080' de los
# pods (Línea 11)

# Guardamos sin salir.

# Aplicamos ambos archivos.

kubectl apply -f lab-35-helloContainer-deployment.yaml

kubectl apply -f lab-35-helloContainer-service.yaml


# Comprobamos que se hayan creado los objetos:

kubectl get all

# Miramos cómo ha quedado el servicio interno.

kubectl get service hello-container-internal-service


# La salida del comando anterior será similar a esta:
#
# NAME                               TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)    AGE
# hello-container-internal-service   ClusterIP   10.101.242.181   <none>        4000/TCP   8m15s

# El tipo 'ClusterIP' y la ausencia de 'EXTERNAL-IP' identifican al servicio como INTERNO.


# Procedemos ahora al despliegue de la segunda aplicación.

# Esta contiene un Frontend, un Backend, un secreto y un configmap.

# El objeto 'secret' y el 'configmap' no tienen cambios. Aplicamos directamente sus archivos YAML.

kubectl apply -f lab-35-mongodb-secret.yaml

kubectl apply -f lab-35-mongodb-configmap.yaml


# Comprobamos que se ha creado el secreto.

kubectl get secret mongodb-secret

# La salida debe ser parecida a esta:
# 
# NAME             TYPE     DATA   AGE
# mongodb-secret   Opaque   2      40s


# Hacemos lo propio para el configmap.

kubectl get configmap mongodb-configmap


# Y la salida es:
#
# NAME                DATA   AGE
# mongodb-configmap   1      12h


# Procedemos a desplegar el Frontend y el Backend.


# El Backend no sufre cambios, editamos el archivo para recordarlo:

code lab-35-mongodb.yaml

# Las líneas 42 y 43 define el puerto en el que escuchará sel servicio de backend ('27017') y 
# el tráfico será reenviado al puerto '27017' del pod de mongodb server.

# Salimos sin modificar nada.


# Por último, para el Frontend si hay cambios. 
# Editamos el archivo 'lab-35-mongo-express.yaml'

code lab-35-mongo-express.yaml


# El cambio más notable es que NO APARECE el parámetro 'type: LoadBalancer' en la especificación del servicio.
# Esto lo convierte en un SERVICIO INTERNO.

# Además, en la línea 42, se cambia el nombre del servicio a 'mongo-express-internal-service'.

# Por otro lado, el servicio escucha en el puerto 5000 (Línea 49) y reenvía el tráfico al puerto '8081' del
# pod 'mongo-express' (Línea 50)

# Guardamos sin salir.




# Comprobamos los objetos presentes en el cluster.

kubectl get all 


# Solo debe quedar el servicio de Kubernetes.
# NAME                 TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE
# service/kubernetes   ClusterIP   10.96.0.1    <none>        443/TCP   53m



#######################
# FIN DEL LABORATORIO #
#######################

