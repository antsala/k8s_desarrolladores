# Laboratorio 03-B: "Construir imágenes desde Dockerfile"
 
# Este laboratorio repasaremos cómo crear imágenes desde Dockerfile,
# integrando la compilación del código fuente en tiempo de creación de
# la imagen.

# Requisitos:
#   Una máquina virtual con Ubuntu 20.04 LTS a la que poder hacer ssh.
#   Tener instalado Docker-ce en dicha máquina virtual.

####################################################
# Ejercicio 1: Creación de imagen desde Dockerfile #
####################################################

# Cambiamos al directorio del laboratorio:

cd ~/k8s_desarrolladores/03/web_estatica


# En este directorio tenemos un archivo de ejemplo llamado 'Dockerfile', que editamos para
# estudiarlo

code Dockerfile


# Este archivo Dockerfile es muy sencillo y realiza lo siguiente:
#
# Línea 2:      Utiliza como imagen base Ubuntu 16.04.
#
# Línea 3:      Actualiza repositorio de paquetes e instala nginx.
#
# Línea 4:      Crea el archivo /var/www/html/index.html y le añade el contenido 'Hola, 
#               estoy dentro de tu contenedor'. De ahí el nombre de web estática.
#
# Línea 5:      Expone el puerto 80 en el contenedor.


# Procedemos a crear una imagen basada en este Dockerfile, así que cerramos el editor y, en la
# consola escribimos el siguiente comando:

sudo docker image build -t antsala/web_estatica .


# Cuando finalice la compilación de la imagen, listamos imágenes.

sudo docker image ls


##################################################
# Ejercicio 2: Publicación de puertos en el host #
##################################################

# Para poder acceder al contenedor, es necesario publicar un puerto en el host. 
# Tenemos dos métodos:
#
#   1) Dejar que Docker asigne un puerto aleatorio (32768-61000)
#   2) Elegir nosotros el puerto externo que más nos guste.
#
# El siguiente comando abrirá un puerto aleatorio en el host y lo conectará con el puerto 80 del contenedor.

sudo docker run -d -p 80 --name web_estatica antsala/web_estatica nginx -g "daemon off;"


# Comprobamos que el contenedor está corriendo:

sudo docker container ls


# La salida del comando anterior tendrá la siguiente forma:
#
# CONTAINER ID   IMAGE                  COMMAND                  CREATED          STATUS          PORTS                                     NAMES
# aeac57545f04   antsala/web_estatica   "nginx -g 'daemon of…"   32 seconds ago   Up 30 seconds   0.0.0.0:49153->80/tcp, :::49153->80/tcp   web_estatica
#
# Observar la columna 'PORTS'. Aparecen los nateos para IPv4 e IPv6. En ambos casos, el puerto externo, en este
# ejemplo es el '49153' (Nota: utilizar el que realmente aparezca)

puerto=<poner aquí el puerto externo>

curl localhost:$puerto


# Tras la ejecución de 'curl', veremos la response con el mensaje "Hola, estoy dentro de tu contenedor".


# Para poder elegir el puerto externo, usamos la sintaxis '-p puerto_externo:puerto_contenedor'. Por ejemplo,
# si queremos publicar la web estática en el puerto '8080' del host, el contenedor debe crearse con el
# siguiente comando:

sudo docker run -d -p 8080:80 --name web_estatica_8080 antsala/web_estatica nginx -g "daemon off;"


# Al igual que antes procedemos a listar los contenedores y probar la conexión con 'curl'

sudo docker container ls

curl localhost:8080


# Debe funcionar correctamente.


#############################################
# Ejercicio 3: 'ENTRYPOINT' en 'Dockerfile' #
#############################################

# En el Dockerfile suele ponerse el comando 'ENTRYPOINT' o el comando 'CMD', que sirven para indicar el programa
# o aplicación que se ejecutará al iniciar el contenedor. De esta forma, no será necesario indicar el ejecutable
# en la línea del 'docker run'.
#
# Procedamos a abrir el archivo 'Dockerfile_entry' en el directorio de trabajo

sudo docker image build -t antsala/web_estatica_entry . -f Dockerfile_entry


# Comprobamos las imágenes:

sudo docker image ls


# La salida del comando debe ser similar a esta:
#
# REPOSITORY                   TAG       IMAGE ID       CREATED          SIZE
# antsala/web_estatica_entry   latest    c0887b707b1c   58 seconds ago   222MB
# antsala/web_estatica         latest    b1813072ba8d   23 minutes ago   222MB
# antsala/apache2              latest    9f6e1d4e26ca   5 hours ago      220MB
# ubuntu                       latest    2b4cba85892a   9 days ago       72.8MB
# nginx                        latest    c919045c4c2b   12 days ago      142MB
# ubuntu                       16.04     b6f507652425   6 months ago     135MB

# Procedemos a crear un nuevo contenedor publicando el puerto 80 del host.
# Nótese que ya no es necesario indicar el ejecutable en la línea de 'docker run'

sudo docker run -d -p 80:80 --name web_estatica_80_entry antsala/web_estatica_entry


# Procedemos a listar los contenedores y probar la conexión con 'curl'

sudo docker container ls

curl localhost:80


# Subimos la imagen 'antsala/web_estatica' a DockerHub. 
# Nos autenticamos en DockerHub.

sudo docker login


# Subimos la imagen.

sudo docker image push antsala/web_estatica

sudo docker logout


# Eliminamos los contenedores:

sudo docker container rm -f `sudo docker container ls -a -q`


#####################################################
# Ejercicio 4: 'ENTRYPOINT' y 'CMD' en 'Dockerfile' #
#####################################################

# En muchos Dockerfiles, aparacen conjuntamente los comandos 'ENTRYPOINT' y 'CMD'. Cuando se da esta
# coincidencia se debe interpretar de la siguiente forma: 
#
#   1) 'ENTRYPOINT' se utiliza para indicar cual es la aplicación o programa que queremos ejecutar en 
#       el contenededor. 
#
#   2) 'CMD' establece los parámetros por defecto que se usarán al llamar a ese ejecutable. 
#
# Docker empleará los parámetros por defecto si en la línea de 'docker run' no se especifican parámetros.

# Veámoslo con un ejemplo. En el directorio de trabajo tenemos el archivo 'Dockerfile_entry_cmd'. Lo editamos:

code Dockerfile_entry_cmd













