# Laboratorio 20-B: "Comandos básicos de kubectl"
 
# Este laboratorio aprenderemos a usar kubectl e interactuaremos con el
# cluster de Kubernetes.

# Requisitos:
#   Una máquina virtual con Ubuntu 20.04 LTS a la que poder hacer ssh.
#   La VM debe tener descargado el binario de 'Minikube' y la herramienta
#   'kubectl'.   
#
#   Es decir, haber realizado el laboratorio anterior (lab-20-A)

# Iniciamos el Minikube.

minikube start --driver=podman


# En primer lugar verificamos que tenemos un solo nodo en el cluster.
# El único nodo deberá esta ejecutando el 'Control Plane'.

kubectl get nodes


# Consultamos los pods que está ejecutando el cluster. No deben haber ninguno.

kubectl get pods


# Comprobamos los servicios que están corriendo en el cluster.
# De haber uno, llamado 'Kubernetes', que es precisamente el endpoint al que se conecta 
# la herramienta 'kubectl'. En consecuencia, nunca debemos eliminar este servicio.

kubectl get services


# Vamos a proceder a crear objetos en Kubernetes. Para ello hacemos uso del comando 'kubectl create'.
# La ayuda muestra todos los tipos (kind) de objetos que se pueden crear.

kubectl create --help


# Estos son los objetos que iremos creando a lo largo del curso, ya sea con 'kubectl create' o, más
# habitualmente, en archivos de manifiesto o declarativos con sintaxis YAML.

# clusterrole         Crea un rol en el cluster.
# clusterrolebinding  Asocia un rol de cluster a un objeto/usuario del cluster
# configmap           Crea un config map desde un archivo, directorio o valor literal.
# cronjob             Programa la ejecucion de un pod.
# deployment          Crea deployments.
# ingress             Crea un controlador ingress para asociar URIs con los servicios.
# job                 Crea un job.
# namespace           Crea un espacio de nombres para conseguir aislar objetos entre aplicaciones.
# poddisruptionbudget Determina el número mínimos de pods en ejecución durante las operaciones de mantenimiento del cluster.
# priorityclass       Crea una clase de prioridad, lo que permite desahuciar (evict) pods con prioridad baja si no hay recursos en el cluster.
# quota               Crea cuotas (cpu, memoria, GPU, storage, ...) para los pods 
# role                Crea un rol.
# rolebinding         Asocia el rol.
# secret              Crea un secreto en el cluster.
# service             Crea un servicio.
# serviceaccount      Crea una cuenta de servicio.


# El pod es la unidad más pequeña de computación en Kubernetes, pero en la práctica los pods se crearán al 
# definir otro objeto, el 'deployment', que creará los pods.
#
# Para crear un deployment, debemos indicar como mínimo, la imagen que se usará en su contenedor.

kubectl create deployment nginx-deployment --image=nginx:latest


# Para ver los deployments, ejecutamos el siguiente comando.

kubectl get deployments

# La salida del comando debe ser similar a esta:
#
# NAME               READY   UP-TO-DATE   AVAILABLE   AGE
# nginx-deployment   1/1     1            1           111s
#
#
# El significado de las columnas es el siguiente:
#
# NAME:         Muestra el nombre del deployment, en este caso 'nginx-deployment'
#
# READY:        Indica cuántos pods (del total) están ejecutándose. En ese caso, el deployment solo tiene un
#               pod, y éste se está ejecutando. 
#
# UP-TO-DATE:   Cuando se actualice el deployment, pod ejemplo si cambiamos la imagen de los contenedores de sus pods,
#               Esta columna indicará cuantos pods están actualizados.
#
# AVAILABLE:    Indica el número de pods que han pasado las pruebas 'readiness'. Esto se verá más adelante en el curso,
#               pero si quieres verlo por adelantado, consulta esto: 
#               'https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/'
#
# AGE:          Tiempo desde que se creó el deployment.
#


# Los deployments crean los pods. Para ver los pods ejecutamos el siguiente comando.

kubectl get pods


# La salida del comando anterior debe ser similar a esta:
#
# NAME                                READY   STATUS    RESTARTS   AGE
# nginx-deployment-7fd6754bf7-29ft2   1/1     Running   0          13m
#
#
# El significado y el valor de cada columna es el siguiente:
#
# NAME:         Nombre del pod. En este ejemplo 'nginx-deployment-7fd6754bf7-29ft2'. El nombre del pod es una 
#               concatenación del nombre del deployment, el nombre del objeto ReplicaSet y un identificador
#               para el pod. Es decir:
#
#               'nginx-deployment' es el nombre del deployment que creó el pod.
#
#               '7fd6754bf7' hace referencia a un objeto 'ReplicaSet', asociado al Deployment. El objeto
#               ReplicaSet es quien está controlando, en todo momento, que el número de pods que forma el 
#               deployment sea el deseado. Si algún pod cae, el ReplicaSet creará otro nuevo. 
#
#               En este ejemplo, hemos creado un deployment sin indicar cuántos pods queremos (réplicas), así
#               que solo se instancia un único pod.
#
#               '29ft2' Es el identificador del pod dentro del ReplicaSet. Cada pod en el ReplicaSet, tendrá un
#               valor único en este campo.
#
# READY:        Indican cúantos CONTENEDORES están corriendo en el Pod.
#
# STATUS:       Indica el estado de ejecución del Pod. Si al menos un Contenedor se inicia, pondrá "Running".
#
# RESTARTS:     Indica cuántos reinicios se han producido en el Pod. Si es >0, suele indicar que algo no va bien y, 
#               en consecuencia, el orquestador está reiniciando el Pod.
#
# AGE:          Indica el tiempo transcurrido desde que se creo el Pod.











