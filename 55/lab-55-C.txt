# Laboratorio 55-C: "MySQL replicado con StatefulSet"
 
# Este laboratorio aprenderemos a usar el objeto 'StatefulSet'.

# Vamos desplegar topología replicada de MongoDB, usando un contenedor Sidecar

# Requisitos:
#
#   1) Una máquina virtual con Ubuntu 20.04 LTS a la que poder hacer ssh.
#
#   2) Cluster Minikube iniciado.


# Como ya hemos aprendido en este curso, deseamos aportar la capacidad de autoescalado al
# ReplicaSet, pero en este caso usaremos otra técnica que hace uso de un 'Sidecar'.
#
# El 'Sidecar' monitorizará los pods y, si se levanta una nueva réplica de MongoDB, el Sidecar la
# añadirá al ReplicaSet. Así mismo, si realizamos retiramos pods, el Sidecar lo tendrá en cuenta.
#
# Otra cuestión a aprender es conseguir que nuestros despliegues en Kubernetes sean seguros, así que
# tendremos en cuenta las buenas prácticas a usar con MongoDB. Protegeremos las comunicaciones entre
# los nodos MongoDB por medio de una clave, crearemos un usuario y habilitaremos la autenticación.



###################################################
# Ejercicio 1: Crear secretos y script de inicio. #
###################################################

# La documentación de MongoDB nos dice que la imagen tiene la posibilidad de configurar scripts
# y ejecutarlos la primera vez que se inicia el contenedor. Utilizaremos esta técnica para configurar
# un usuarios (y passwords)

# Cambiamos al directorio de trabajo:

cd ~/k8s_desarrolladores/55

# Una técnica muy interesante el crear un script y almacenarlo en un CONFIGMAP. El script leerá
# información confidencial que se almacena en un secreto.

# Estudiemos el archivo del secreto.

code lab-55-C-mongo-secret.yaml


# Las líneas más destacables son:
#
# Línea 2:      Indica que estamos creando un secreto.
#
# Línea 5:      Con nombre 'mongo-secret'.
#
# Líneas 7 y 8: Codificación en Base64 de los passwords para los usuarios 'root' y 'mi_database_user'.
#               El password de 'root' es 'Pa55w.rdRoot'. El password de 'mi_database_user' es 'Pa55w.rdUser'.

# Salimos sin modificar nada y aplicamos:

kubectl apply -f lab-55-C-mongo-secret.yaml


# A continuación declaramos un 'ConfigMap' que almacenará el script. Este script leerá el nombre de 
# del usuario administrador y su password desde variables de entorno cargadas a su vez desde el secreto.

# Echamos un vistazo al siguiente archivo:

code lab-55-C-mongo-init-configmap.yaml


# Las líneas más importantes son:
#
# Línea 2:      Es un 'ConfigMap'
#
# Línea 4:      Su nombre es 'mongo-init-script'.
#
# Línea 6:      El script se llama 'mongo-user-sh'.
#
# Líneas 7-12:  El script crea un usuario administrador cuyo nombre y password se toma respectivamente de las 
#               variables de entorno 'MONGO_INITDB_ROOT_USERNAME' y 'MONGO:_INITDB_ROOT_PASSWORD' que serán
#               inicializadas desde el secreto.
#
#               Posteriormente crea (si no existe) una base de datos con nombre 'mi_database'. Luego da de
#               alta un usuario llamado 'mi_database-user' con el password definido en la variable de entorno
#               'SECOND_USER_DB_PASSWORD'. A este usuario se le da el permiso RW en la base de datoa que se acaba
#               de crear.

# Cerramos sin modificar nada y aplicamos el ConfigMap:

kubectl apply -f lab-55-C-mongo-init-configmap.yaml


# Comprobamos que se ha creado correctamente:

kubectl describe configmap mongo-init-script



########################################################
# Ejercicio 2: Proteger las comunicaciones de MongoDB. #
########################################################

# MongoDB puede (y debe) cifrar las comunicaciones entre sus instancias. Para ello simplemente debemos
# proporcionar una clave a modo de vector de inicialización para el algoritmo de cifrado. Esta clave la
# almacenamos en un ConfigMap.

# Editamos el archivo:

code lab-55-C-mongo-key.yaml


# Las líneas más importantes son:
#
# Línea 2:      Es un 'ConfigMap'.
#
# Línea 4:      El nombre del ConfigMap es 'mongo-key'.
#
# Línea 5 y 6:  Nombre de la clave y su valor.


# Salimos sin modificar nada y aplicamos:

kubectl apply -f lab-55-C-mongo-key.yaml


# Comprobamos:

kubectl get configmap mongo-key


############################################
# Ejercicio 3: Cambiar permisos al script. #
############################################

# Cuando Mongo se ejecute necesitaremos proporcionar permisos para la 'mongo-key'. Debido a que se
# los valores almacenador por los 'ConfigMaps' se cargarán en el sistema de archivos del contenedor Mongo, 
# debemos tener cuidado con los permisos de archivo.
#
# El contenedor Mongo se inicia con el usuario 'mongodb' y no con el 'root', así que tenemos que cambiar los
# permisos y luego iniciar Mongo. Para conseguirlo cargamos temporalmente el ConfigMap 'mongo-key' en una
# carpeta temporal, que luego copiaremos en otra ruta mejor. 
#
# La razón de hacer esto es que el contenedor carga el 'ConfigMap' como un enlace simbólico en el sistema de
# archivos y por ello no nos permitirá cambiar ni el propietario ni los permisos del archivo. Para conseguir
# esto nos apoyamos en otro script.

# Abrimos el archivo:

code lab-55-C-mongo-script-permissions.yaml


# Las líneas más importantes son:
#
# Línea 2:      Es un 'ConfigMap'.
#
# Línea 4:      El nombre es 'mongo-scripts-permissions'.
#
# Línea 6:      Nombre del script.
#
# Línea 7:      Se copia el directorio temporal a la ruta '/var/lib/mongoKey', se cambia propietario y se
#               asigna permiso de lectura al archivo de la clave.

# Cerramos sin cambiar nada y aplicamos:

kubectl apply -f lab-55-C-mongo-script-permissions.yaml


# Comprobamos:

kubectl get configmap mongo-script-permissions



############################################################
# Ejercicio 4: Creación del servicio y cuenta de servicio. #
############################################################

# Procedemos a crear un servicio interno de tipo headless.

# Estudiamos el siguiente código:

code lab-55-C-mongo-service.yaml


# Las líneas más importantes son:
#
# Línea 2:      Es un servicio.
#
# Línea 11:     'ClusterIP: none' indica que es un servicio 'Headless' (Sin dirección IP).


# Salimos sin modificar y aplicamos:

kubectl apply -f lab-55-C-mongo-service.yaml


# Comprobamos

kubectl get service mongo


# La salida es parecida a la siguiente:
# (Nota: Observar como no tiene 'CLUSTER-IP')
#
# NAME    TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)     AGE
# mongo   ClusterIP   None         <none>        27017/TCP   20s

# Vamos a crear un espacio de nombres para tener organizado los roles que vamos a crear:

kubectl create namespace mongodb-repl-system



# Procedemos a crear una 'Service Account' y un 'Cluster Role Binding' ya que los sidecars necesitan 
# permisos para observar al pod. Solo es necesario aportar el permiso 'watch' y 'list', pero en este
# ejemplo asignamos más para que podamos entender cómo se asignan.

# Editamos el siguiente archivo:

code lab-55-C-service-account-rbac.yaml


# El contenido más interesante es el siguiente:
#
# Líneas 1-5:   Define una 'Service Account'.
# 
# Línea 4:      El nombre de la cuenta es 'mongo-account'.
#
# Línea 5:      MUY IMPORTANTE: Se crea el espacio de nombres 'mongodb-repl-system'.


# Líneas 7-23:  Se crea un Rol en el cluster.
#
# Línea 10:     El rol se llama 'mongo-role'.
# 
# Líneas 12-14: Se asignan todos los permisos para los 'ConfigMaps'.
#
# Líneas 15-17: Se asignan los permisos 'list' y 'watch' en el contexto de los 'Deployments'.
#
# Líneas 18-20: Se asignan todos los permisos en el contexto de 'Services'.
#
# Líneas 21-23: Se asignan los permisos 'get', 'list' y 'watch' en los 'Pods'.


# Líneas 25-36: Se asigna el rol y la cuenta de servicio al cluster
#
# Línea 28:     El 'ClusterRoleBinding' se llama 'mongo_role_binding'
#
# Líneas 30-32: Se asigna la cuenta de servicio al cluster en el espacio de nombres 'mongodb-repl-system'.
#
# Líneas 33-36: Se signa el rol al cluster en el mismo espacio de nombres.


# Salimos sin modificar nada y aplicamos:

kubectl apply -f lab-55-C-service-account-rbac.yaml


# Comprobamos que se ha creado el rol:

kubectl describe clusterrole mongo-role --namespace mongodb-repl-system


# La salida es como esta:
#
# Name:         mongo-role
# Labels:       <none>
# Annotations:  <none>
# PolicyRule:
#   Resources      Non-Resource URLs  Resource Names  Verbs
#   ---------      -----------------  --------------  -----
#   configmaps.*   []                 []              [*]
#   services.*     []                 []              [*]
#   pods.*         []                 []              [get list watch]
#   deployments.*  []                 []              [list watch]


# Comprobamos el 'roleBinding':

kubectl describe clusterrolebinding mongo-role-binding --namespace mongodb-repl-system


# La salida es como la siguiente:
#
# Name:         mongo-role-binding
# Labels:       <none>
# Annotations:  <none>
# Role:
#   Kind:  ClusterRole
#   Name:  mongo-role
# Subjects:
#   Kind            Name           Namespace
#   ----            ----           ---------
#   ServiceAccount  mongo-account  mongodb-repl-system



#######################################################
# Ejercicio 5: Creación del 'StatefulSet' de MongoDB. #
#######################################################

# Procedemos a crear el 'StatefulSet' con dos contenedores. El primero es el de MongoDB, mientras que el
# segundo será el 'Sidecar'.

# Editamos el archivo:

code lab-55-C-mongo-statefulset.yaml




#######################
# FIN DEL LABORATORIO #
#######################
