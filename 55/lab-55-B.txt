# Laboratorio 55-B: "MySQL replicado con StatefulSet"
 
# Este laboratorio aprenderemos a usar el objeto 'StatefulSet'.

# Vamos desplegar topología replicada de MySQL (Basado en ejemplo de web Kunernetes.io)

# Requisitos:
#
#   1) Una máquina virtual con Ubuntu 20.04 LTS a la que poder hacer ssh.
#
#   2) Cluster Minikube iniciado.


En este laboratorio desplegaremos un ConfigMap, dos servicios y un StatefulSet.


####################################
# Ejercicio 1: Crear el ConfigMap. #
####################################

# Cambiamos al directorio de trabajo:

cd ~/K8s_desarrolladores/55


# Editamos el YAML del ConfigMap para estudiarlo.

code lab-55-B-MySQL-ConfigMap.yaml 


# Las líneas más relevantes son:
#
# Línea 2:          Es un 'ConfigMap'.
#
# Líneas 7-15:      Define dos claves: 'primary.cnf' y 'replica-cnf' que serán tenidas en cuenta en función
#                   del rol que asignemos a cada pod de MySQL. Se aplican de la siguiente forma:
#
#                   'primary.cnf': Se aplicará al servidor MySQL que actúe como master o primario. En este
#                   ejemplo el servidor primario enviará logs de replicación a los servidores que actúan 
#                   como réplicas.
#
#                   'replica.cnf': Las réplicas de MySQL leerán esta clave que significa que rechazarán todas 
#                   las operaciones de escritura que no provengan desde logs de replicación del primario.


# Creamos el ConfigMap.

kubectl apply -f lab-55-B-MySQL-ConfigMap.yaml


# Comprobamos que se ha creado correctamente:

kubectl get configmap mysql 

kubectl describe configmap mysql 



###########################################
# Ejercicio 2: Creación de los servicios. #
###########################################

# Procedemos a crear los servicios de la app.
#
# El primer servicio servirá para enviar tráfico al pod maestro de MySQL. Si bien podemos usar un
# servicio de la forma que hemos aprendido hasta el momento, es preciso conocer formas más eficientes.
#
# Para hacer operaciones de escritura en la base de datos, necesitamos enviar el tráfico al pod primario,
# es decir, a un único pod. Por lo tanto, podríamos decir que el pod de frontend debería conectar directamente
# con el pod primario de MySQL. Esto contradice las buenas prácticas que hemos visto, y que 'obligan' a que 
# el tráfico pase por un servicio.
#
# Para solventar esta necesidad, Kubernetes permite crear un tipo de servicio especial llamado 'Headless'.
#
# Un servicio 'Headless' no asigna dirección IP ni reenvía tráfico, ni balancea. Lo que realmente ofrece 
# un servicio Headless, y por esto es buena práctica su uso, es un nombre DNS que podrá usar que el Frontend
# para alcanzar la instancia primaria (pod) de una base de datos.

# En Kubernetes decimos que queremos un servicio 'Headless' de estas características cambiando el tipo del 
# servicio de 'ClusterIP' a 'None' en el archivo de manifiesto.
#

# El archivo 'lab-55-B-MySQL-services.yaml' define los dos servicios que necesita esta app.

code lab-55-B-MySQL-services.yaml


# Las líneas más interesantes son:
#
# Líneas: 1-14:     Declaración del servicio 'Headless' para alcanzar el servidor primario de MySQL.
#
# Línea 5:          Este servicio se llamará 'mysql'.
#
# Línea 11:         Se usará el puerto '3306' en el servicio.
#
# Línea 12:         Al poner 'ClusterIP: None' estamos definiendo un servicio 'Headless'.
#
# Línea 16:         En YAML, los caracteres '---' indican que se procede a definir un nuevo objeto.
#
# Líneas 13-14:     Este segundo servicio de asociará con pods que tenga definida la etiqueta 'app: mysql'.
#
# Líneas: 18-30:    Definición del sergundo servicio que será usado para balancear las operaciones de lectura
#                   a los pods de la base de datos.
#
# Línea 22:         El servicio se llamará 'mysql-read'.


# Creamos los servicios:

kubectl apply -f lab-55-B-MySQL-services.yaml


# Comprobamos:

kubectl get services


# La salida será similar a esta:
# (Nota: Observar como el servicio Headless no tiene 'CLUSTER-IP')
#
# NAME         TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)    AGE
# kubernetes   ClusterIP   10.96.0.1       <none>        443/TCP    5d15h
# mysql        ClusterIP   None            <none>        3306/TCP   26s
# mysql-read   ClusterIP   10.99.195.131   <none>        3306/TCP   26s

# Como hemos comentado, un servicio 'Headless' proporciona un sufijo de DNS común para los pods que crea 
# el 'StatefulSet'. Puesto que al servicio 'Headless' le hemos asignado el nombre 'mysql', los pods
# pueden ser resueltos en la forma de '<nombre_del_pod>.mysql' DESDE CUALQUIER OTRO POD en el
# que esté en el mismo espacio de nombres.
#
# En breve crearemos el 'StatefulSet', que tendrá un nombre, por ejemplo 'mysql'. 
#
# A diferencia del 'Deployment' que genera identificadores aleatorios para el nombre del pod, el 'StatefulSet'
# los NUMERA. En consecuencia los nombres de los pods serán: mysql-0, mysql-1, mysql-2, etc...
#
# Pues ahora lo ponemos todo junto. Si el primer pod del StatefulSet es el primario de MySQL, su nombre 
# DNS será 'mysql-0.mysql', donde '.mysql' es el sufijo DNS que aporta el servicio HeadLess.
#
# En consecuencia el Frontend deberá conectar con 'mysql-0.mysql' (o 'mysql-0.mysql.default.svc.cluster.local' 
# si se prefiere) para hacer operaciones de escritura. Realmente estamos contactando con un pod, pero
# usando la DNS que proporciona el servicio Headless.
#
# Para las consultas de lectura, los pods de Frontend contactan contra el servicio 'mysql-read'.



##########################################
# Ejercicio 3: Creación del StatefulSet. #
##########################################

# Procedemos a crear el 'StatefullSet'.

# Editamos el archivo lab-55-B-statefulset.yaml

code lab-55-B-statefulset.yaml


# Debido a la importancia de los contenidos que vamos a aprender, comentamos las líneas más importantes:
#
# Línea 2:          Definimos un objeto 'StatefulSet'.
#
# Líneas 6-8:       Este 'StatefulSet' gestionará las réplicas del pod que tiene declarada la etiqueta 'app: mysql'.
#
# Línea 9:          Nombre del servicio (mysql) con el que está asociado este StatefulSet.
#
# Línea 10:         Deseamos 3 réplicas (1 primaria y 2 en RO)
#
# Línea 11-Final:   Blueprint. Definición de los contenedores del pod.
#
# Línea 16:         'initContainers'. Kubernetes se asegura de iniciar los contenedores de esta sección antes de proceder
#                   con el inicio del resto de contenedores declarados en el pod.
#
# Línea 17-63:      Se define el contenedor de inicio.
#
# Línea 17:         Se llama 'init-mysql'. Su misión solo es la de copiar el archivo de configuración de MySQL en función de
#                   si el pod va a tener el rod de primario o réplica.
#
# Líneas 19-35:     'CMD' Comando que se ejecuta al iniciar el contenedor. 
#                   MUY IMPORTANTE!!! Observar cómo se copia al volumen el archivo de configuración 
#                   del ConfigMap en función del rol de la instancia. La primera (id 0) será la maestra.
#
# Línea 65:         Su nombre es 'mysql'
#
# Línea 72:         El contenedor se expone en el puerto '3306'.        
#
# Líneas 73-78:     Volúmenes que monta el contenedor.
#
# Líneas 74-76:     Monta el archivo 'mysql' en '/var/lib/mysql'. Ver líneas 159-166.
#
# Líneas 37 y 38:   Monta un volumen local de tipo 'EmptyDir' en '/mnt/conf.d'. Ver líneas 154 y 155.
#
# Líneas 39 y 40:   Monta el volumen '/mnt/config-map' con el ConfigMap llamado 'config-map'.
#
# Líneas 41-63:     Definición de otro contenedor de inicio.
#
# Línea 41:         Su nombre es 'clone-mysql'. 
#
# Líneas 43-57:     Determina si el pod se corresponde con la instancia primaria o con una réplica.
#                   Si es una réplica y el volumen ya contiene el archivo de la base de datos, entonces termina.
#                   Si el pod es el master, no hace nada y termina.
#                   En este último caso, el pod es una réplica y no tiene el archivo de la base de datos, así que se
#                   lo copia desde el pod anterior.
#                   Por último se asegura de que el archivo de la base de datos sea consistente para que sea restaurado
#                   cuando se levante el pod de la instancia.
#
# Líneas 58-62:     Monta los volúmenes 'data' en '/var/lib/mysql' y el ConfigMap en '/etc/mysql/conf.d'.
#
#                   En este punto se ha terminado con la definición de los contenedores de incio. A continuación
#                   tenemos los contenedores que quedarán funcionando en el pod.
#
# Líneas 65-95:     Definición del contenedor llamado 'mysql'.
#
# Líneas 73-78:     Monta el volumen 'data' en '/var/lib/mysql' (el archivo de de la base de datos) y el volumen
#                   'conf' en '/etc/mysql/conf.d' que contiene el ConfigMap.
#
# Líneas 79-82:     500 milis de CPU y 1 Gi de RAM para el contenedor.
#
# Líneas 83-95:     Sondas 'Liveness' y 'Readiness' que serán explicadas más adelante.
#
# Líneas 96-152:    Definición del contenedor sidecar o helper 'xtrabackup'. Su misión es iniciar/continuar la replicación
#                   desde el master (si el pod es el de una réplica). Luego monta un servidor de backup y 
#                   se queda a la espera de que otro contenedor (de inicio) le pida el backup.


# Aplicamos el 'StatefulSet'.

kubectl apply -f lab-55-B-statefulset.yaml 


# Comprobamos:

kubectl get all

TOTE, estoy haciendo este lab.
https://kubernetes.io/docs/tasks/run-application/run-replicated-stateful-application/




#######################
# FIN DEL LABORATORIO #
#######################
